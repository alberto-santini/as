<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="namespaceas" kind="namespace" language="C++">
    <compoundname>as</compoundname>
    <innerclass refid="structas_1_1and__die" prot="public">as::and_die</innerclass>
    <innerclass refid="classas_1_1iterator__pair" prot="public">as::iterator_pair</innerclass>
    <innerclass refid="structas_1_1TwoDimPoint" prot="public">as::TwoDimPoint</innerclass>
    <innernamespace refid="namespaceas_1_1console">as::console</innernamespace>
    <innernamespace refid="namespaceas_1_1details">as::details</innernamespace>
    <innernamespace refid="namespaceas_1_1graph">as::graph</innernamespace>
    <innernamespace refid="namespaceas_1_1oplib">as::oplib</innernamespace>
    <innernamespace refid="namespaceas_1_1string">as::string</innernamespace>
    <innernamespace refid="namespaceas_1_1tmp">as::tmp</innernamespace>
    <innernamespace refid="namespaceas_1_1tsplib">as::tsplib</innernamespace>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="namespaceas_1a9bd788709567003423247a9db4ba1074" prot="public" static="no">
        <type>decltype(std::declval&lt; Container &gt;().count(std::declval&lt; T &gt;()))</type>
        <definition>using as::count_method_type = typedef decltype(std::declval&lt;Container&gt;().count(std::declval&lt;T&gt;()))</definition>
        <argsstring></argsstring>
        <name>count_method_type</name>
        <briefdescription>
<para>This is the type of a generic .count() method for a container. </para>        </briefdescription>
        <detaileddescription>
<para>count_method_type This method is implemented in some stl containers and takes an element as its only parameter. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/containers.h" line="28" column="1" bodyfile="src/containers.h" bodystart="28" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespaceas_1a9e0fcaa3ddb46647d8979282465685da" prot="public" static="no">
        <type><ref refid="namespaceas_1_1tmp_1a44a275bd3c66d727fb1b6f0179d49e19" kindref="member">tmp::can_apply</ref>&lt; <ref refid="namespaceas_1a9bd788709567003423247a9db4ba1074" kindref="member">count_method_type</ref>, Container, T &gt;</type>
        <definition>as::has_count_method</definition>
        <argsstring></argsstring>
        <name>has_count_method</name>
        <briefdescription>
<para>This will inherit from true_type iff class Container has an appopriate .count() method. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/containers.h" line="34" column="1" bodyfile="src/containers.h" bodystart="34" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="namespaceas_1a4d891ae352512e1c506d6cd01ff1422c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream&amp; as::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;out, const and_die &amp;)</argsstring>
        <name>operator&lt;&lt;</name>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
        </param>
        <param>
          <type>const <ref refid="structas_1_1and__die" kindref="compound">and_die</ref> &amp;</type>
        </param>
        <briefdescription>
<para>Concatenates a <ref refid="structas_1_1and__die" kindref="compound">and_die</ref> structure to an output stream, to immediately terminate a programme. </para>        </briefdescription>
        <detaileddescription>
<para>When concatenating an object of type <ref refid="structas_1_1and__die" kindref="compound">and_die</ref> to an ostream, the programme is going to terminate with exit code EXIT FAILURE. This can be used in the following way:</para><para>using namespace as; std::cerr &lt;&lt; console::error &lt;&lt; &quot;A terrible error has occurred!&quot; &lt;&lt; and_die();</para><para>It adds a new line before terminating the programme.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>out</parametername>
</parameternamelist>
<parameterdescription>
<para>The output stream currently used. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>In theory the same output stream, but in practice the programme dies and nothing is returned. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/and_die.h" line="31" column="1" bodyfile="src/and_die.h" bodystart="31" bodyend="35"/>
      </memberdef>
      <memberdef kind="function" id="namespaceas_1a49cf7ae4239ab51e54f099d30a84811a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Container</type>
          </param>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool as::contains</definition>
        <argsstring>(const Container &amp;container, const T &amp;element)</argsstring>
        <name>contains</name>
        <param>
          <type>const Container &amp;</type>
          <declname>container</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>element</declname>
        </param>
        <briefdescription>
<para>Tells whether a container contains a certain element. </para>        </briefdescription>
        <detaileddescription>
<para>The standard library&apos;s functions to find elements (e.g. std::find) always return an iterator. Sometimes, though, we just want to know whether an element is in a container or not. This helper function lets us do this in a concise way. This function also has specialisation for when the container implements a .count() method, i.e. a more efficient way of searching elements than simple linear search.</para><para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Container</parametername>
</parameternamelist>
<parameterdescription>
<para>Container type. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>Containee type. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>container</parametername>
</parameternamelist>
<parameterdescription>
<para>The container. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>element</parametername>
</parameternamelist>
<parameterdescription>
<para>The element we are searching in <computeroutput>container</computeroutput>. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True iff <computeroutput>element</computeroutput> was found in <computeroutput>container</computeroutput>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/containers.h" line="66" column="1" bodyfile="src/containers.h" bodystart="66" bodyend="68"/>
      </memberdef>
      <memberdef kind="function" id="namespaceas_1aab6569c28591bebed9bd29b40c772bfc" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Container</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void as::join_and_print</definition>
        <argsstring>(const Container &amp;container, std::ostream &amp;out=std::cout, std::string separator=&quot;, &quot;)</argsstring>
        <name>join_and_print</name>
        <param>
          <type>const Container &amp;</type>
          <declname>container</declname>
        </param>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
          <defval>std::cout</defval>
        </param>
        <param>
          <type>std::string</type>
          <declname>separator</declname>
          <defval>&quot;, &quot;</defval>
        </param>
        <briefdescription>
<para>Joins the elements of a container using the separator, and prints the result to an output stream. </para>        </briefdescription>
        <detaileddescription>
<para>It works both with key-value and value-only containers. In the first case, it prints both key and value.</para><para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Container</parametername>
</parameternamelist>
<parameterdescription>
<para>Container type. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>container</parametername>
</parameternamelist>
<parameterdescription>
<para>The container to print. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>out</parametername>
</parameternamelist>
<parameterdescription>
<para>Output stream. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>separator</parametername>
</parameternamelist>
<parameterdescription>
<para>A string interposed between two adjacent elements. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/containers.h" line="96" column="1" bodyfile="src/containers.h" bodystart="96" bodyend="103"/>
      </memberdef>
      <memberdef kind="function" id="namespaceas_1a359f2d209e5ec052ec0d2752a589802d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void as::skip_lines</definition>
        <argsstring>(std::ifstream &amp;stream, std::size_t how_many=1u)</argsstring>
        <name>skip_lines</name>
        <param>
          <type>std::ifstream &amp;</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>how_many</declname>
          <defval>1u</defval>
        </param>
        <briefdescription>
<para>Skips a certain number of lines from an input file stream. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>stream</parametername>
</parameternamelist>
<parameterdescription>
<para>The file stream. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>how_many</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of lines to skip. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/file_stream.h" line="18" column="1" bodyfile="src/file_stream.h" bodystart="18" bodyend="22"/>
      </memberdef>
      <memberdef kind="function" id="namespaceas_1a4d4e0fb99b7cc564adaa85b693392070" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Iterator</type>
          </param>
        </templateparamlist>
        <type><ref refid="classas_1_1iterator__pair" kindref="compound">iterator_pair</ref>&lt; Iterator &gt;</type>
        <definition>iterator_pair&lt;Iterator&gt; as::make_iter</definition>
        <argsstring>(std::pair&lt; Iterator, Iterator &gt; iters)</argsstring>
        <name>make_iter</name>
        <param>
          <type>std::pair&lt; Iterator, Iterator &gt;</type>
          <declname>iters</declname>
        </param>
        <briefdescription>
<para>Gives an <ref refid="classas_1_1iterator__pair" kindref="compound">iterator_pair</ref> object constructed from the beginning and end iterators, given as a pair. </para>        </briefdescription>
        <detaileddescription>
<para>Many boost functions return iterators in pairs, for example boost::vertices or boost::edges. This function can be used with the pairs returned by these methods, to create an object that can be used with range-based for loops. Example:</para><para>for(const auto&amp; vertex : make_iter(boost::vertices(graph)) { ... }</para><para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Iterator</parametername>
</parameternamelist>
<parameterdescription>
<para>Iterator type. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>iters</parametername>
</parameternamelist>
<parameterdescription>
<para>A pair containing the beginning and end iterator. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>An IteratorPair storing the beginning and end iterators. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/iterator_pair.h" line="60" column="1" bodyfile="src/iterator_pair.h" bodystart="60" bodyend="62"/>
      </memberdef>
      <memberdef kind="function" id="namespaceas_1a4c9b0919bddf60796e9cc81ecd7d5bb2" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::mt19937</type>
        <definition>std::mt19937 as::get_seeded_mt</definition>
        <argsstring>()</argsstring>
        <name>get_seeded_mt</name>
        <briefdescription>
<para>Gets a properly seeded Mersenne Twister prng. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>A seeded instance of std::mt19937. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/random.h" line="18" column="1" bodyfile="src/random.h" bodystart="18" bodyend="27"/>
      </memberdef>
      <memberdef kind="function" id="namespaceas_1a001b8303767234a8c93de5cb530a8f3d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Container</type>
          </param>
          <param>
            <type>class Prng</type>
            <defval>std::mt19937</defval>
          </param>
        </templateparamlist>
        <type>Container</type>
        <definition>Container as::sample</definition>
        <argsstring>(const Container container, typename Container::size_type how_many, Prng &amp;&amp;prng)</argsstring>
        <name>sample</name>
        <param>
          <type>const Container</type>
          <declname>container</declname>
        </param>
        <param>
          <type>typename Container::size_type</type>
          <declname>how_many</declname>
        </param>
        <param>
          <type>Prng &amp;&amp;</type>
          <declname>prng</declname>
        </param>
        <briefdescription>
<para>Gets samples from a container. The samples are guaranteed to be unique. If we are requesting more samples than elements in the container, the request is ignored, and instead a random permutation of the container is returned. </para>        </briefdescription>
        <detaileddescription>
<para>A copy of the input container is made, so this method might be unsuitable for particularly large containers.</para><para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Container</parametername>
</parameternamelist>
<parameterdescription>
<para>The container type. Must be copiable, implement begin() and end(), and constructible from a pair of iterators. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Prng</parametername>
</parameternamelist>
<parameterdescription>
<para>The pseudo-random number generator type to use. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>container</parametername>
</parameternamelist>
<parameterdescription>
<para>The container to sample. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>how_many</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of samples to extract. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>prng</parametername>
</parameternamelist>
<parameterdescription>
<para>The pseudo-random number generator. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A container with how_many elements from container. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/random.h" line="47" column="1" bodyfile="src/random.h" bodystart="47" bodyend="74"/>
      </memberdef>
      <memberdef kind="function" id="namespaceas_1ab2b3e64b4dee388f0ec34e41ae0b3e98" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Container</type>
          </param>
        </templateparamlist>
        <type>Container</type>
        <definition>Container as::sample</definition>
        <argsstring>(const Container container, typename Container::size_type how_many)</argsstring>
        <name>sample</name>
        <param>
          <type>const Container</type>
          <declname>container</declname>
        </param>
        <param>
          <type>typename Container::size_type</type>
          <declname>how_many</declname>
        </param>
        <briefdescription>
<para>Gets samples from a container. The samples are guaranteed to be unique. If we are requesting more samples than elements in the container, the request is ignored, and instead a random permutation of the container is returned. </para>        </briefdescription>
        <detaileddescription>
<para>A copy of the input container is made, so this method might be unsuitable for particularly large containers. A Mersenne Twister pseudo-random number generator is built, seeded and used to extract the samples.</para><para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Container</parametername>
</parameternamelist>
<parameterdescription>
<para>The container type. Must be copiable, implement begin() and end(), and constructible from a pair of iterators. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>container</parametername>
</parameternamelist>
<parameterdescription>
<para>The container to sample. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>how_many</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of samples to extract. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A container with how_many elements from container. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/random.h" line="94" column="1" bodyfile="src/random.h" bodystart="94" bodyend="96"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="src/and_die.h" line="11" column="1"/>
  </compounddef>
</doxygen>
